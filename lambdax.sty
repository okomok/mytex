\ProvidesPackage{lambdax}

\usepackage{lambda,etoolbox}


% References
%   https://www.ctan.org/tex-archive/macros/generic/lambda-lists?lang=en
%   https://en.wikipedia.org/wiki/Church_encoding
%   http://d.hatena.ne.jp/melpon/20111005/1317799929
%   http://0-chromosome.hatenablog.jp/entry/2015/12/02/000000
%   http://tex.stackexchange.com/questions/24922/comparing-an-argument-to-a-string-when-argument-is-a-result-of-a-command-with-et


% Note
%   Don't use \relax, which isn't expandable, for equality-tests.


% Workarounds
%

% "\And" conflicts somewhere?
\def\And{\Undefined}
\newcommand*{\BoolAnd}[2]{#1{#2}\False}
\newcommand*{\BoolOr}{\Or}
\newcommand*{\BoolNot}{\Not}
\def\All#1{\Foldr{\Compose\BoolAnd{#1}}\True}


% Bool
%

\newcommand*{\Bool}{\TeXif}
\newcommand*{\If}{\Identity}
\newcommand*{\Iftex}{\TeXif}


% Function
%

\newcommand*{\Apply}[2]{#1{#2}}
\newcommand*{\Flip}{\Twiddle}
\newcommand*{\Then}{\Flip\Compose}
\newcommand*{\Const}{\First}


% Prelude
%

\newcommand*{\ErrorMsg}[1]{\errmessage{error: #1}}
\newcommand*{\Assert}[2]{\If{#1}{#2}{\ErrorMsg{assertion failed}}}
\newcommand*{\Undefined}{\errmessage{undefined}}


% Test
%

\newcommand*{\AssertTrue}[1]{\Assert{#1}{}}
\newcommand*{\AssertFalse}[1]{\Assert{\Not{#1}}{}}


% List
%

\newcommand*{\Null}{\Isempty}

\newcommand*{\Unlist}[1]{#1\UnlistImpl{}}
\newcommand*{\UnlistImpl}[1]{#1\Foldr\PrependComma{}}

\newcommand*{\List}[1]{\ListImpl#1,\ListendImpl\@eolst}
\newcommand*{\ListendImpl}{}
\def\ListImpl#1,#2\@eolst{%
    \Iftex{\ifx\ListendImpl#2}{\Singleton{#1}}{\Cons{#1}{\ListImpl#2\@eolst}}%
}
\newcommand*{\ShowList}[1]{[\Unlist{#1}]}

\newcommand*{\Iterate}[2]{\Cons{#2}{\Iterate{#1}{#1{#2}}}}

\newcommand*{\Length}{\Foldr\Length@{0}}
\newcommand*{\Length@}[2]{\Inc@{#2}}
\newcommand*{\Inc@}[1]{\ifcase#1 1\or2\or3\or4\or5\or6\or7\or8\or9\or10\or11\or12\or13\or14\or15\or16\or17\or18\or19\or20\else\Undefined\fi}

\newcommand*{\Take}[2]{\Foldr\Take@{\Const\Nil}{#2}{#1}}
\newcommand*{\Take@}[3]{%
    \Iftex{\ifnum#3=0 }{%
        \Nil%
    }{%
        \Cons{#1}{#2{\numexpr#3-1}}%
    }%
}

\newcommand*{\Drop}[2]{\Foldr\Drop@{\Const\Nil}{#2}{#1}}
\newcommand*{\Drop@}[3]{%
    \Iftex{\ifnum#3=0 }{%
        \Cons{#1}{#2{0}}%
    }{%
        #2{\numexpr#3-1}%
    }%
}
\newcommand*{\Nth}[2]{\Head{\Drop{#1}{#2}}}

\newcommand*{\TakeWhile}[2]{\Foldr{\TakeWhile@{#1}}\Nil{#2}}
\newcommand*{\TakeWhile@}[3]{\If{#1{#2}}{\Cons{#2}{#3}}\Nil}

\newcommand*{\DropWhile}[2]{%
    \Foldr{\DropWhile@{#1}}{\Const\Nil}{#2}\True%
}
\newcommand*{\DropWhile@}[4]{%
    \If{#4}{%
        \If{#1{#2}}{%
            #3\True%
        }{%
            \Cons{#2}{#3\False}%
        }%
    }{%
        \Cons{#2}{#3\False}%
    }%
}

\newcommand*{\Zip}{\ZipWith{\ConsPair}}
\newcommand*{\ZipWith}[1]{\Foldr{\ZipWith@{#1}}{\Const\Nil}}
\newcommand*{\ZipWith@}[4]{%
    \If{\Null{#4}}{%
        \Nil%
    }{%
        \Cons{#1{#2}{\Head{#4}}}{#3{\Tail{#4}}}%
    }%
}

\newcommand*{\EqualWith}[1]{\Foldr{\EqualWith@{#1}}{\Null}}
\newcommand*{\EqualWith@}[4]{%
    \If{\Null{#4}}{%
        \False%
    }{%
        \If{#1{#2}{\Head{#4}}}{%
            #3{\Tail{#4}}%
        }{%
            \False%
        }%
    }%
}

\newcommand*{\Foreach}[2]{\ForeachImpl{\Fun{#2}}{#1}}
\newcommand*{\ForeachImpl}[1]{\Foldr{\ForeachImpl@{#1}}{}}
\newcommand*{\ForeachImpl@}[3]{#1{#2}#3}


% Lambda
%

\newcommand*{\FunNamed@}[2]{%
    \expandafter\newcommand\csname#1\endcsname[1]{#2}\csuse{#1}%
}
\newcounter{Funcounter}
\newcommand*{\Fun}{%
    \stepcounter{Funcounter}%
    \FunNamed@{Fun\the\value{Funcounter}}%
}


% Pair
%

\newcommand*{\ConsPair}[3]{#3{#1}{#2}}
\newcommand*{\Fst}[1]{#1\True}
\newcommand*{\Snd}[1]{#1\False}
\newcommand*{\Curry}[3]{#1{\ConsPair{#2}{#3}}}
\newcommand*{\Uncurry}[2]{#1{\Fst{#2}}{\Snd{#2}}}
\newcommand*{\Swap}[1]{\ConsPair{\Snd{#1}}{\Fst{#1}}}
\newcommand*{\Pair}[1]{\Pair@#1}
\def\Pair@#1,#2{\ConsPair{#1}{#2}}
\newcommand*{\Unpair}[1]{\Fst{#1},\Snd{#1}}
\newcommand*{\ShowPair}[1]{(\Unpair{#1})}
\newcommand*{\PairToList}[1]{\Cons{\Fst{#1}}{\Cons{\Snd{#1}}\Nil}}


% Misc
%

\newcommand*{\Unuse}[1]{}
\newcommand*{\PrependComma}[2]{,#1#2}% no spaces

\newcommand*{\In}[2]{\Foldr\In@{#2}{\List{#1}}}
\newcommand*{\In@}[2]{\begin{#1}#2\end{#1}}

